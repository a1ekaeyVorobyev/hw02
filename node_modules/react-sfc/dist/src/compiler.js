"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
const estree_walker_1 = require("estree-walker");
const { Parser } = require("acorn");
const magic_string_1 = __importDefault(require("magic-string"));
const hooks = [
    "useState",
    "useEffect",
    "useContext",
    "useReducer",
    "useCallback",
    "useMemo",
    "useRef",
    "useImperativeHandle",
    "useLayoutEffect",
    "useDebugValue",
];
function Compiler(args) {
    // console.log({acorn})
    function defaultacorn(x) {
        const MyParser = Parser.extend(require('acorn-jsx')());
        return MyParser.parse(x, {
            sourceType: "module",
        });
    }
    const parser = args.parser || defaultacorn;
    const ast = parser(args.code);
    let ms = new magic_string_1.default(args.code);
    const isProduction = false; // TODO: figure out how to get this from rollup
    // undocumented option - tbd if we actually want to let users configure
    // TODO: can make it dev-only, or maybe also useful in prod?
    const userWantsUSWL = args.useStateWithLabel || !isProduction;
    let STYLECONTENT, STYLEDECLARATION; //  typescript is stupid about assignment inside an if, thinks this is a `never` or a `undefined`
    let STYLESTATICCSS; // just stubbing this out
    let lastChildofDefault; //  typescript is stupid about assignment inside an if, thinks this is a `never` or a `undefined`
    let pos_HeadOfDefault;
    let stateMap = new Map();
    let assignmentsMap = new Map();
    let bindValuesMap = new Map();
    let isReactImported = false;
    estree_walker_1.walk(ast, {
        enter(node, parent, prop, index) {
            var _a;
            if (node.type === "ImportDeclaration") {
                let _node = node;
                if (_node.source.value === "react")
                    isReactImported = true;
                // TODO: check that the name React is actually defined!
                // most people will not run into this, but you could be nasty
            }
            if (node.type === "CallExpression") {
                let _node = node; // CallExpression would be nice but SimpleLiteral is annoying
                if (hooks.some((hook) => _node.callee.name === hook)) {
                    ms.prependLeft(_node.callee.start, "React.");
                }
            }
            if (node.type === "ExportNamedDeclaration") {
                let _node = node.declaration;
                if (_node &&
                    _node.type === "VariableDeclaration" &&
                    (_node === null || _node === void 0 ? void 0 : _node.declarations[0].id.type) === "Identifier") {
                    if ((_node === null || _node === void 0 ? void 0 : _node.declarations[0].id.name) === "STYLE") {
                        let loc = _node.declarations[0].init; // klooge as i believe TemplateLiteral type is incomplete
                        // TODO: check return type of ArrowFunctionExpression as well
                        /**
                         *
                         * MVP of css static export feature
                         *
                         */
                        if (loc.type === "TemplateLiteral" && loc.quasis.length === 1) {
                            STYLESTATICCSS = loc.quasis[0].value.raw;
                            // TODO: namespace to scope to component
                            // TODO: take care of css nesting
                        }
                        /**
                         *
                         * end MVP of css static export feature
                         *
                         */
                        if (loc) {
                            STYLEDECLARATION = node;
                            STYLECONTENT = ms.slice(loc.start, loc.end);
                        }
                        // TODO - consider whether to handle Literal (just string)
                        // TODO - there are bunch of other expression types we may someday need to support (unlikely)
                    }
                }
            }
            if (node.type === "ExportDefaultDeclaration") {
                let _node = node.declaration; // TODO: consider other expressions
                if (_node.body.type === "BlockStatement") {
                    let RSArg = (_a = _node.body.body.find((x) => x.type === "ReturnStatement")) === null || _a === void 0 ? void 0 : _a.argument; // TODO: this type is  missing JSXElement
                    if (RSArg.type === "JSXElement")
                        lastChildofDefault = RSArg.children.slice(-1)[0];
                    // use start and end
                    else
                        throw new Error("not returning JSX in export default function"); // TODO: fix this?
                }
                pos_HeadOfDefault = _node.body.start + 1;
            }
            // usestate
            if (node.type === "VariableDeclaration") {
                let dec = node
                    .declarations[0];
                if (dec.id.type === "Identifier" && dec.id.name.startsWith("_")) {
                    stateMap.set(dec.id.name, {
                        node,
                        value: ms.slice(dec.init.start, dec.init.end),
                    });
                }
            }
            // SETSTATE
            if (node.type === "AssignmentExpression") {
                // todo: maybe only read assignmentexpressions if the LHS is in the stateMap
                let LHS = node.left;
                if (LHS.type === "Identifier" && LHS.name.startsWith("_")) {
                    assignmentsMap.set(LHS.name, { node });
                }
            }
            if (node.type === "UpdateExpression") {
                // todo: maybe only read assignmentexpressions if the LHS is in the stateMap
                let ID = node.argument;
                if (ID.name.startsWith("_")) {
                    assignmentsMap.set(ID.name, { node });
                }
            }
            // BINDING
            if (node.type === "JSXAttribute") {
                // // bind:value syntax - we may want to use this in future?
                // let _node = node as JSXAttribute;
                // if (
                //   _node.name.type === "JSXNamespacedName" &&
                //   _node.name.namespace.name === "bind"
                // ) {
                //   let RHSobject, RHSname;
                //   // TODO: in future - support RHS which is just a Literal? MAAAYBE, maybe not
                //   if (_node.value.type === "JSXExpressionContainer") {
                //     if (_node.value.expression.type === "Identifier") {
                //       // RHS is just an identifier
                //       RHSname = _node.value.expression.name;
                //     } else if (_node.value.expression.type === "MemberExpression") {
                //       // RHS is an object access
                //       let exp = _node.value.expression as MemberExpression & ASTNode;
                //       RHSobject = {
                //         objectName:
                //           (exp.object as Identifier).name ||
                //           ((exp.object as MemberExpression).object as Identifier).name, // either its an identifier '$foo.bar` or a memberexpression `$foo.bar.baz`
                //         fullAccessName: ms.slice(exp.start, exp.end),
                //       };
                //     } else {
                //       throw new Error(
                //         "warning - unrecognized RHS expression type in binding: " +
                //           _node.value.expression.type +
                //           ". We will probably do this wrong, pls report this along with your code"
                //       );
                //     }
                //   }
                //   bindValuesMap.set(
                //     node, // to replace
                //     {
                //       // LHSname: _node.name.name.name.slice(1), // only tested to work for 'value'. remove the leading $
                //       LHSname: _node.name.name.name, // only tested to work for 'value'. remove the leading $
                //       RHSname,
                //       RHSobject,
                //     }
                //   );
                // }
                // $ prefix syntax
                let _node = node;
                if (_node.name.type === "JSXIdentifier" &&
                    _node.name.name.startsWith('$')) {
                    let RHSobject, RHSname;
                    // TODO: in future - support RHS which is just a Literal? MAAAYBE, maybe not
                    if (_node.value.type === "JSXExpressionContainer") {
                        if (_node.value.expression.type === "Identifier") {
                            // RHS is just an identifier
                            RHSname = _node.value.expression.name;
                        }
                        else if (_node.value.expression.type === "MemberExpression") {
                            // RHS is an object access
                            let exp = _node.value.expression;
                            RHSobject = {
                                objectName: exp.object.name ||
                                    exp.object.object.name,
                                fullAccessName: ms.slice(exp.start, exp.end),
                            };
                        }
                        else {
                            throw new Error("warning - unrecognized RHS expression type in binding: " +
                                _node.value.expression.type +
                                ". We will probably do this wrong, pls report this along with your code");
                        }
                    }
                    bindValuesMap.set(node, // to replace
                    {
                        LHSname: _node.name.name.slice(1),
                        RHSname,
                        RHSobject,
                    });
                }
            }
        },
    });
    /*
    
    // process it!
    
    */
    if (!isReactImported)
        ms.prepend(`import React from 'react';`);
    // remove STYLE and insert style jsx
    if (STYLEDECLARATION && STYLECONTENT) {
        ms.remove(STYLEDECLARATION.start, STYLEDECLARATION.end);
        if (lastChildofDefault)
            ms.appendRight(lastChildofDefault.end, `<style jsx>{${STYLECONTENT}}</style>`);
    }
    // useState
    if (stateMap.size) {
        // for each state hook
        stateMap.forEach(({ node, value }, key) => {
            ms.remove(node.start, node.end);
            let newStr;
            if (userWantsUSWL) {
                // should be 'let' bc we want to mutate it
                newStr = `\nlet [${key}, set${key}] = use${key}_State(${value})`;
                // i would like to use only one instance, of useStateWithLabel
                // https://stackoverflow.com/questions/57659640/is-there-any-way-to-see-names-of-fields-in-react-multiple-state-with-react-dev
                // but currently devtools uses the NAME OF THE HOOK for state hooks
                // rather than useDebugValue. so we do a simple alias of the hook
                ms.append(`
function use${key}_State(v) {
  const x = React.useState(v);
  ${isProduction ? 'return x;' : `React.useDebugValue('${key}: ' + x[0]); return x;`}
}`);
            }
            else {
                // just plain useState
                // should be 'let' bc we want to mutate it
                newStr = `\nlet [${key}, set${key}] = React.useState(${value})`;
            }
            ms.appendRight(pos_HeadOfDefault, newStr);
        });
    }
    // setState
    if (assignmentsMap.size) {
        assignmentsMap.forEach(({ node }, key) => {
            // strategy: use comma separator to turn
            // $count = $count + 1
            // into
            // ($count = $count + 1, set$count($count))
            ms.prependLeft(node.start, "(");
            ms.appendRight(node.end, `, set${key}(${key}))`);
        });
    }
    // binding
    if (bindValuesMap.size) {
        bindValuesMap.forEach(({ LHSname, RHSname, RHSobject }, node) => {
            if (RHSobject) {
                // create new object, mutate new object, THEN set it
                // must be new object or react doesnt rerender
                ms.overwrite(node.start, node.end, `${LHSname}={${RHSobject.fullAccessName}} 
        onChange={e => {
          let temp = Object.assign({}, ${RHSobject.objectName});
          temp${RHSobject.fullAccessName.slice(RHSobject.objectName.length)} = e.target.${LHSname};
          set${RHSobject.objectName}(temp);
        }}`);
            }
            else if (RHSname) {
                ms.overwrite(node.start, node.end, `${LHSname}={${RHSname}} onChange={e => set${RHSname}(e.target.${LHSname})}`);
            }
            else {
                throw new Error("we should not get here. pls repurt this binding bug");
            }
        });
    }
    let code = ms.toString();
    return {
        js: {
            code,
            map: null,
        },
        css: {
            // TODO
            // TODO
            // TODO
            // TODO
            // TODO
            // TODO
            // TODO
            // static css
            // THIS WHOLE THING IS A MASSIVE TODO
            code: STYLESTATICCSS,
            map: null,
        },
    };
}
exports.Compiler = Compiler;
